/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package CS4488.Capstone.System;



import CS4488.Capstone.Executor.ExecutorFacade;
import CS4488.Capstone.Library.FacadeInterfaces.ExecutorAccess;
import CS4488.Capstone.Library.FacadeInterfaces.NumberConverterAccess;
import CS4488.Capstone.Library.FacadeInterfaces.ProgramStateAccess;
import CS4488.Capstone.Library.FacadeInterfaces.TranslatorAccess;
import CS4488.Capstone.Library.Tools.FileManager;
import CS4488.Capstone.Library.Tools.Hex4digit;
import CS4488.Capstone.Library.Tools.HexadecimalConverter;
import CS4488.Capstone.Library.Tools.ProgramState;
import CS4488.Capstone.Translator.TranslatorFacade;
import java.util.ArrayList;

/**
 * The Back End Facade Class that orchestrates everything else.
 *
 * @version 0.0.9
 * @author Traae
 */
public class Orchestrator implements ProgramStateAccess, TranslatorAccess, ExecutorAccess, NumberConverterAccess {
    // SINGLETON INSTANCE
    private static Orchestrator instance = null;

    // INSTANCE VARIABLES
    private ProgramState state;
    private TranslatorFacade translator;
    private ExecutorFacade executor;
    private FileManager fileManager;
    private String error;
    //private String currentFile;



    private Orchestrator(){
        state = ProgramState.getInstance();
        translator = new TranslatorFacade();
        executor = new ExecutorFacade();
        fileManager = FileManager.getInstance();
        //currentFile = null;
        this.resetError();
    }

    public static Orchestrator getInstance() {
        if (instance==null){
            instance = new Orchestrator();
        }
        return instance;
    }

    private void resetError(){
        error = "Orchestrator: No Error.";
    }

    public String getError() {
        return error;
    }

//    public String getCurrentFile() {
//        return currentFile;
//    }

    @Override
    public boolean next() {
        resetError();
        boolean result = executor.hasState();
        if (result == false){
            error = "Executor" + executor.getLastExceptionMessage();
            return result;
        }

        result = executor.hasNext();
        if (result == false){
            error = "Executor" + executor.getLastExceptionMessage();
            return result;
        }

        result = executor.next();
        if (result == false){
            error = "Executor" + executor.getLastExceptionMessage();
        }
        return result;
    }

    public void clearProgram(){
        executor.clearState();
        //currentFile = null;
    }


    @Override
    public ProgramState getProgramState() {
            return state;
    }

    @Override
    public void sendInput(char[] input) {
        state.input.setValue(input);
    }

    @Override
    public char[] getOutput() {
        return state.output.getHexChars();
    }

    @Override
    public boolean translateAndLoad(String path) {
        resetError();
        boolean result;

        result = translator.loadFile(path);
        if (result == false) {
            error = "Translator" + translator.getLastExceptionMessage();
            return result;
        }

        result = translator.isTranslatable();

        if (result == false){
            error = "Translator" + translator.getLastExceptionMessage();
        }

        state.clearProgramState();
        ArrayList<Hex4digit> code = translator.translateToMachine();
        // Set up the emulator
        state.initializeState(code);
        executor.setProgramState(state);
        translator.clearFile();
        // Save the output code for utility sake.
        //currentFile = path;
        //saveHex(code, currentFile);

        return result;
    }


    @Override
    public char[] convertToHexChars(Short number) {
        return HexadecimalConverter.decimalToHex(number);
    }

    @Override
    public int convertToInt(char[] number) {
        return HexadecimalConverter.hexToDecimal(number);
    }


    /**
     * Returns the contents of a file
     * @param path a file path
     * @return txt file contents
     */
    public String loadFile(String path){

        return fileManager.fileToString(path);
    }

//    public boolean saveHex(ArrayList<Hex4digit> code, String path){
//        boolean result = false;
//        StringBuilder build = new StringBuilder();
//
//        for (Hex4digit h : code){
//            build.append(h.getString());
//            build.append("\n");
//        }
//
//
//        String hexPath = path.replace(".", "HEX.");
//        result = fileManager.saveFile(build.toString(), hexPath);
//
//        return result;
//    }
//
//    public boolean saveFile(String content, String path){
//        boolean result = false;
//        System.out.println(content + "\n\n PATH:" + path);
//        result = fileManager.saveFile(content, path);
//        return result;
//    }





}
